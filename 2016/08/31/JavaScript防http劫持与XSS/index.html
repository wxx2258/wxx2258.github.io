<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="前端知识总结,网络安全," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="本篇整理一些常见情况下前端对于网络攻击的防范。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript防http劫持与XSS">
<meta property="og:url" content="http://yoursite.com/2016/08/31/JavaScript防http劫持与XSS/index.html">
<meta property="og:site_name" content="Wxx's blog">
<meta property="og:description" content="本篇整理一些常见情况下前端对于网络攻击的防范。">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816180031328-287202588.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816175136203-1054607098.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816175507062-1668275500.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816175607671-745079353.png">
<meta property="og:updated_time" content="2016-08-31T13:34:24.397Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript防http劫持与XSS">
<meta name="twitter:description" content="本篇整理一些常见情况下前端对于网络攻击的防范。">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816180031328-287202588.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> JavaScript防http劫持与XSS | Wxx's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?5a81bb25f4a74a4ec7999f0c15191703";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Wxx's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'rLFP8c9G6YyjxLUsEh_M','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaScript防http劫持与XSS
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-31T20:13:37+08:00" content="2016-08-31">
              2016-08-31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/31/JavaScript防http劫持与XSS/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/31/JavaScript防http劫持与XSS/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本篇整理一些常见情况下前端对于网络攻击的防范。</p>
<a id="more"></a>
<h2 id="常见网络攻击"><a href="#常见网络攻击" class="headerlink" title="常见网络攻击"></a>常见网络攻击</h2><p>web前端常见的需要注意和防范的就是 XSS ， CSRF跨站请求伪造 ， HTTP劫持、DNS劫持。</p>
<h3 id="XSS跨站脚本"><a href="#XSS跨站脚本" class="headerlink" title="XSS跨站脚本"></a>XSS跨站脚本</h3><p>XSS指的是攻击者漏洞，向 Web 页面中注入恶意代码，当用户浏览该页之时，注入的代码会被执行，从而达到攻击的特殊目的。</p>
<p>关于这些攻击如何生成，攻击者如何注入恶意代码到页面中本文不做讨论，只要知道如 HTTP 劫持 和 XSS 最终都是恶意代码在客户端，通常也就是用户浏览器端执行，本文将讨论的就是假设注入已经存在，如何利用 Javascript 进行行之有效的前端防护。</p>
<h3 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h3><p>CSRF攻击大概的意思就是，攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p>
<h3 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h3><p>什么是HTTP劫持呢，大多数情况是运营商HTTP劫持，当我们使用HTTP请求请求一个网站页面的时候，网络运营商会在正常的数据流中插入精心设计的网络数据报文，让客户端（通常是浏览器）展示“错误”的数据，通常是一些弹窗，宣传性广告或者直接显示某网站的内容，大家应该都有遇到过。 </p>
<h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。</p>
<p>DNS 劫持就更过分了，简单说就是我们请求的是 <a href="http://www.a.com/index.html" target="_blank" rel="external">http://www.a.com/index.html</a> ，直接被重定向了 <a href="http://www.b.com/index.html" target="_blank" rel="external">http://www.b.com/index.html</a> 。</p>
<h2 id="页面被嵌入iframe-，重定向iframe"><a href="#页面被嵌入iframe-，重定向iframe" class="headerlink" title="页面被嵌入iframe ，重定向iframe"></a>页面被嵌入iframe ，重定向iframe</h2><p>这种页面被嵌入iframe的情况，也就是，网络运营商为了尽可能地减少植入广告对原有网站页面的影响，通常会通过把原有网站页面放置到一个和原页面相同大小的 iframe 里面去，那么就可以通过这个 iframe 来隔离广告代码对原有页面的影响。</p>
<p><img src="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816180031328-287202588.png" alt="image"></p>
<ul>
<li>检测我们的页面是否存在于iframe<ul>
<li>window.self : 返回一个指向当前 window 对象的引用。</li>
<li>window.top : 返回窗口体系中的最顶层窗口的引用。</li>
<li>对于非同源的域名，iframe子页面无法通过parent.location 或者 top.location 拿到具体的页面地址，但可以写入top.location，也就是可以控制父页面的跳转。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//两个属性可以简写为self 与 top，当发现我们的页面被嵌套在iframe中，可以重定向到父级页面。</span><br><span class="line">if(self != top)&#123;</span><br><span class="line">    var url = location.href;    //我们的正常页面</span><br><span class="line">    top.location = url;     //父级页面重定向</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用白名单放行正常iframe嵌套"><a href="#使用白名单放行正常iframe嵌套" class="headerlink" title="使用白名单放行正常iframe嵌套"></a>使用白名单放行正常iframe嵌套</h2><p>很多时候，由于运营商需要，我们的页面会被以各种方式推广，也有可能是正常业务需要被嵌套在iframe中，这个时候我们需要一个白名单或者黑名单，当我们的页面被嵌套在iframe中，且父级页面域名存在白名单中，则不做重定向操作。</p>
<ul>
<li>使用top.location.href 是无法拿到父级页面的 URL 的，这时候，就需要使用document.referrer。</li>
<li>通过document.referrer 可以拿到跨域iframe父页面的URL。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//白名单</span><br><span class="line">var whiteList = &#123;</span><br><span class="line">    &apos;www.aaa.com&apos;,</span><br><span class="line">    &apos;www.bbb.com&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">if(self != top)&#123;</span><br><span class="line">    //document.referrer 可以拿到跨域iframe父页面的URL</span><br><span class="line">    var parentURL = document.referrer;</span><br><span class="line">    var length = whiteList.length;</span><br><span class="line">    var i = 0;</span><br><span class="line">    for(;i&lt;length;i++)&#123;</span><br><span class="line">        // 建立白名单正则</span><br><span class="line">        var reg = new RegExp(whiteList[i],&apos;i&apos;);</span><br><span class="line">     </span><br><span class="line">        // 存在白名单中，放行</span><br><span class="line">        if(reg.test(parentUrl))&#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //重定向</span><br><span class="line">    var url = location.href;</span><br><span class="line">    top.location = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更改-URL-参数绕过运营商标记"><a href="#更改-URL-参数绕过运营商标记" class="headerlink" title="更改 URL 参数绕过运营商标记"></a>更改 URL 参数绕过运营商标记</h2><p>你以为这样就完了么？没有，虽然我们重定向页面，但是在重定向的过程中，既然第一次可以被嵌套，那么这一次重定向的过程也可能被嵌套。</p>
<p>当然，运营商这种劫持通常是有迹可寻的，</p>
<ul>
<li>最常规的手段在页面URL中设置一个参数，例如<a href="http://www.example.com/index.html?iframe_hijack_redirected=1" target="_blank" rel="external">http://www.example.com/index.html?iframe_hijack_redirected=1</a> ，其中iframe_hijack_redirected=1 表示页面已经被劫持过了，就不再嵌套 iframe 了。所以根据这个特性，我们可以改写我们的 URL ，使之看上去已经被劫持了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var flag = &apos;iframe_hijack_redirected&apos;;</span><br><span class="line">// 当前页面存在于一个 iframe 中</span><br><span class="line">// 此处需要建立一个白名单匹配规则，白名单默认放行</span><br><span class="line">var whiteList = &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">if (self != top) &#123;</span><br><span class="line">  var</span><br><span class="line">    // 使用 document.referrer 可以拿到跨域 iframe 父页面的 URL</span><br><span class="line">    parentUrl = document.referrer,</span><br><span class="line">    length = whiteList.length,</span><br><span class="line">    i = 0;</span><br><span class="line"> </span><br><span class="line">  for(; i&lt;length; i++)&#123;</span><br><span class="line">    // 建立白名单正则</span><br><span class="line">    var reg = new RegExp(whiteList[i],&apos;i&apos;);</span><br><span class="line"> </span><br><span class="line">    // 存在白名单中，放行</span><br><span class="line">    if(reg.test(parentUrl))&#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  var url = location.href;</span><br><span class="line">  var parts = url.split(&apos;#&apos;);</span><br><span class="line">  if (location.search) &#123;</span><br><span class="line">    parts[0] += &apos;&amp;&apos; + flag + &apos;=1&apos;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    parts[0] += &apos;?&apos; + flag + &apos;=1&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(&apos;页面被嵌入iframe中:&apos;, url);</span><br><span class="line">    top.location.href = parts.join(&apos;#&apos;);</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当然，如果这个参数一改，防嵌套的代码就失效了。所以我们还需要建立一个上报系统，当发现页面被嵌套时，发送一个拦截上报，即便重定向失败，也可以知道页面嵌入 iframe 中的 URL，根据分析这些 URL ，不断增强我们的防护手段，这个后文会提及。</li>
</ul>
<h2 id="内联事件和内联脚本拦截"><a href="#内联事件和内联脚本拦截" class="headerlink" title="内联事件和内联脚本拦截"></a>内联事件和内联脚本拦截</h2><p>在 XSS 中，其实可以注入脚本的方式非常的多，尤其是 HTML5 出来之后，一不留神，许多的新标签都可以用于注入可执行脚本。</p>
<p>列出一些比较常见的注入方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;a href=&quot;javascript:alert(1)&quot; &gt;&lt;/a&gt;</span><br><span class="line">2. &lt;iframe src=&quot;javascript:alert(1)&quot; /&gt;</span><br><span class="line">3. &lt;img src=&apos;x&apos; onerror=&quot;alert(1)&quot; /&gt;</span><br><span class="line">4. &lt;video src=&apos;x&apos; onerror=&quot;alert(1)&quot; &gt;&lt;/video&gt;</span><br><span class="line">5. &lt;div onclick=&quot;alert(1)&quot; onmouseover=&quot;alert(2)&quot; &gt;&lt;div&gt;</span><br></pre></td></tr></table></figure>
<p>除去一些未列出来的非常少见生僻的注入方式，大部分都是 javascript:… 及内联事件 on*。</p>
<p>我们假设注入已经发生，那么有没有办法拦截这些内联事件与内联脚本的执行呢？</p>
<p>对于上面列出的 (1) (5)，这种需要用户点击或者执行某种事件之后才执行的脚本，我们是有办法进行防御的，这种拦截，就涉及事件模型相关的原理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//建立黑名单</span><br><span class="line">var keywordBlackList = &#123;</span><br><span class="line">  &apos;xss&apos;,</span><br><span class="line">  &apos;blackList&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class="line">  var code = &quot;&quot;;</span><br><span class="line">  //扫描 &lt;a href=&quot;&quot; &gt;&lt;/a&gt;内部脚本</span><br><span class="line">  if(elem.tagName=&quot;A&quot; &amp;&amp; elem.protocol=&quot;javascript:&quot;)&#123;</span><br><span class="line">    var code = elem.href.substr(11);</span><br><span class="line">    if (blackListMatch(keywordBlackList,code)) &#123;</span><br><span class="line">      elem.href = &quot;javascript:void(0)&quot;;</span><br><span class="line">      console.log(&quot;拦截可疑事件&quot;+code);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function blackListMatch(blackList,value)&#123;</span><br><span class="line">  var length = blackList;</span><br><span class="line">  var i = 0;</span><br><span class="line">  for (; i &lt; length; i++) &#123;</span><br><span class="line">    //建立黑名单正则</span><br><span class="line">    var reg = new RegExp(blackList[i],&apos;i&apos;);</span><br><span class="line">    if(reg.test(value))&#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看DEMO（<a href="http://sbco.cc/demo/httphijack/index.html）。(打开页面后打开控制台查看" target="_blank" rel="external">http://sbco.cc/demo/httphijack/index.html）。(打开页面后打开控制台查看</a> console.log)</li>
</ul>
<h2 id="静态脚本拦截"><a href="#静态脚本拦截" class="headerlink" title="静态脚本拦截"></a>静态脚本拦截</h2><p>XSS 跨站脚本的精髓不在于“跨站”，在于“脚本”。</p>
<p>通常而言，攻击者或者运营商会向页面中注入一个<script>脚本，具体操作都在脚本中实现，这种劫持方式只需要注入一次，有改动的话不需要每次都重新注入。</p>
<p>我们假定现在页面上被注入了一个 <script src="http://attack.com/xss.js"> 脚本，我们的目标就是拦截这个脚本的执行。简单来说，就是在脚本执行前发现这个可疑脚本，并且销毁它使之不能执行内部代码。</p>
<ul>
<li>我们需要一个API，能够在页面加载的时候对生成的节点进行检查。</li>
<li>MutationObserver 是 HTML5 新增的API，功能很强大，给开发者们提供了一种能在某个范围内的 DOM 树发生变化时作出适当反应的能力。也就是说可以监测页面DOM树的变化，并作出反应。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//MutationObserver() 该构造函数用来实例化一个新的Mutation观察者对象。</span><br><span class="line"></span><br><span class="line">MutationObserver(</span><br><span class="line">  function callback</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//MutationObserver兼容的不同写法</span><br><span class="line">var MutationObserver = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver;</span><br><span class="line">//构造函数构造一个新的MutationObserver对象</span><br><span class="line">// Mutation观察者对象能监听在某个范围内 DOM 树的变化。</span><br><span class="line">var observer = new MutationObserver (function(mutations)&#123;</span><br><span class="line">  mutations.foreach(function(mutation)&#123;</span><br><span class="line">    // 返回被添加的节点</span><br><span class="line">    var nodes = mutation.addedNodes;</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      var node = nodes[i];</span><br><span class="line">      if( /xss/i.test(nodes[i].src) )&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          node.parentNode.removeChild(node);</span><br><span class="line">          console.log(&quot;拦截可疑脚本&quot;+node);</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 传入目标节点和观察模式</span><br><span class="line">// 如果target为document 或 document.documentElement</span><br><span class="line">// 则当前文档的所有节点变化都会被监测</span><br><span class="line">observer.observer(docuemnt,&#123;</span><br><span class="line">  subtree:true,</span><br><span class="line">  childList:true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到如下：可以戳我查看DEMO（<a href="http://sbco.cc/demo/httphijack/index.html）。(打开页面后打开控制台查看">http://sbco.cc/demo/httphijack/index.html）。(打开页面后打开控制台查看</a> console.log)</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2pVrMuaAe5Jlic0jlia9n1FuwaJTTibK7b9dMWUFY5e4hc9VpRWRUdy0oBxUicSWHGaibnPEgESJaGU3w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="image"></p>
<p><strong><script type="text/javascript" src="./xss/a.js"></script> 是页面加载一开始就存在的静态脚本（查看页面结构），我们使用 MutationObserver 可以在脚本加载之后，执行之前这个时间段对其内容做正则匹配，发现恶意代码则 removeChild() 掉，使之无法执行。</p>
<h3 id="使用白名单对src进行匹配过滤"><a href="#使用白名单对src进行匹配过滤" class="headerlink" title="使用白名单对src进行匹配过滤"></a>使用白名单对src进行匹配过滤</h3><p>上面的代码中，我们判断一个js脚本是否是恶意的，用的是这一句：</p>
<p><strong>if (/xss/i.test(node.src)) {}</strong></p>
<p>当然实际当中，注入恶意代码者不会那么傻，把名字改成 XSS 。所以，我们很有必要使用白名单进行过滤和建立一个拦截上报系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 建立白名单</span><br><span class="line">var whiteList = &#123;</span><br><span class="line">  www.a.com,</span><br><span class="line">  www.b.com</span><br><span class="line">&#125;;</span><br><span class="line">/*</span><br><span class="line"> * [白名单匹配]</span><br><span class="line"> * @param &#123;[Array]&#125; WhiteList[白名单]</span><br><span class="line"> * @param &#123;[String]&#125; value &#123;需要验证的字符串&#125;</span><br><span class="line"> * @return &#123;[Boolean]&#125;  false-验证不通过 ， true-验证通过</span><br><span class="line">*/</span><br><span class="line">function whiteListMatch(whiteList,value)&#123;</span><br><span class="line">  var length = whiteList.length,</span><br><span class="line">    i = 0;</span><br><span class="line"></span><br><span class="line">  for (; i &lt; length; i++) &#123;</span><br><span class="line">    // 建立正则</span><br><span class="line">    var reg = new RegExp(whiteList[i],&apos;i&apos;);</span><br><span class="line"></span><br><span class="line">    if (reg.test(value)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态脚本拦截"><a href="#动态脚本拦截" class="headerlink" title="动态脚本拦截"></a>动态脚本拦截</h2><p>前面我们使用 MutationObserver 拦截静态脚本，出了静态脚本，与之对应就是动态生成的脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.type = &apos;text/javascript&apos;;</span><br><span class="line">script.src = &apos;http://www.example.com/xss/b.js&apos;;</span><br><span class="line"> </span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(script);</span><br></pre></td></tr></table></figure>
<p>要拦截这类动态生成的脚本，且拦截时机要在它插入DOM树中，执行之前，本来是可以监听Mutation Events中的DOMNodeInserted事件的。</p>
<blockquote>
<p>Mutation Events 与 DOMNodeInserted<br>    打开 MDN ，第一句就是:该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。</p>
</blockquote>
<p>这里不展开描述，有兴趣的同学去了解，由于DOMNodeInserted 不再建议使用，所以监听动态脚本的任务也要交给 MutationObserver。</p>
<ul>
<li>在实际实践过程中，使用 MutationObserver 的结果和 DOMNodeInserted 一样，可以监听拦截到动态脚本的生成，但是无法在脚本执行之前，使用 removeChild 将其移除，所以我们还需要想想其他办法。</li>
</ul>
<h2 id="重写setAttribute-与-document-write"><a href="#重写setAttribute-与-document-write" class="headerlink" title="重写setAttribute 与 document.write"></a>重写setAttribute 与 document.write</h2><p>假设现在有一个动态脚本是这样创建的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;);</span><br><span class="line">script.setAttribute(&apos;src&apos;, &apos;http://www.example.com/xss/c.js&apos;);</span><br><span class="line"> </span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(script);</span><br></pre></td></tr></table></figure>
<p>而重写 Element.prototype.setAttribute 也是可行的：我们发现这里用到了 setAttribute 方法，如果我们能够改写这个原生方法，监听设置 src 属性时的值，通过黑名单或者白名单判断它，就可以判断该标签的合法性了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 保存原有接口</span><br><span class="line">var old_setAttribute = Element.prototype.setAttribute;</span><br><span class="line"> </span><br><span class="line">// 重写 setAttribute 接口</span><br><span class="line">Element.prototype.setAttribute = function(name, value) &#123;</span><br><span class="line"> </span><br><span class="line">  // 匹配到 &lt;script src=&apos;xxx&apos; &gt; 类型</span><br><span class="line">  if (this.tagName == &apos;SCRIPT&apos; &amp;&amp; /^src$/i.test(name)) &#123;</span><br><span class="line">    // 白名单匹配</span><br><span class="line">    if (!whileListMatch(whiteList, value)) &#123;</span><br><span class="line">      console.log(&apos;拦截可疑模块:&apos;, value);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  // 调用原始接口</span><br><span class="line">  old_setAttribute.apply(this, arguments);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 建立白名单</span><br><span class="line">var whiteList = [</span><br><span class="line">&apos;www.yy.com&apos;,</span><br><span class="line">&apos;res.cont.yy.com&apos;</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * [白名单匹配]</span><br><span class="line"> * @param  &#123;[Array]&#125; whileList [白名单]</span><br><span class="line"> * @param  &#123;[String]&#125; value    [需要验证的字符串]</span><br><span class="line"> * @return &#123;[Boolean]&#125;         [false -- 验证不通过，true -- 验证通过]</span><br><span class="line"> */</span><br><span class="line">function whileListMatch(whileList, value) &#123;</span><br><span class="line">  var length = whileList.length,</span><br><span class="line">    i = 0;</span><br><span class="line"> </span><br><span class="line">  for (; i &lt; length; i++) &#123;</span><br><span class="line">    // 建立白名单正则</span><br><span class="line">    var reg = new RegExp(whiteList[i], &apos;i&apos;);</span><br><span class="line"> </span><br><span class="line">    // 存在白名单中，放行</span><br><span class="line">    if (reg.test(value)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到如下结果：可以戳我查看DEMO（<a href="http://sbco.cc/demo/httphijack/index.html）。(打开页面后打开控制台查看" target="_blank" rel="external">http://sbco.cc/demo/httphijack/index.html）。(打开页面后打开控制台查看</a> console.log)</p>
<p>重写 Element.prototype.setAttribute ，就是首先保存原有接口，然后当有元素调用 setAttribute 时，检查传入的 src 是否存在于白名单中，存在则放行，不存在则视为可疑元素，进行上报并不予以执行。最后对放行的元素执行原生的 setAttribute ，也就是 old_setAttribute.apply(this, arguments);  </p>
</blockquote>
<h3 id="重写嵌套-iframe-内的-Element-prototype-setAttribute"><a href="#重写嵌套-iframe-内的-Element-prototype-setAttribute" class="headerlink" title="重写嵌套 iframe 内的 Element.prototype.setAttribute"></a>重写嵌套 iframe 内的 Element.prototype.setAttribute</h3><p>当然，上面的写法如果 <strong>old_setAttribute = Element.prototype.setAttribute</strong> 暴露给攻击者的话，直接使用<strong>old_setAttribute</strong> 就可以绕过我们重写的方法了，所以这段代码必须包在一个闭包内。</p>
<p>当然这样也不保险，虽然当前窗口下的 <strong>Element.prototype.setAttribute</strong> 已经被重写了。但是还是有手段可以拿到原生的 <strong>Element.prototype.setAttribute</strong> ，只需要一个新的 iframe 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var newIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">document.body.appendChild(newIframe);</span><br><span class="line"> </span><br><span class="line">Element.prototype.setAttribute = newIframe.contentWindow.Element.prototype.setAttribute;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过这个方法，可以重新拿到原生的 Element.prototype.setAttribute ，因为 iframe 内的环境和外层 window 是完全隔离的。wtf?</li>
</ul>
<p>怎么办？我们看到创建 iframe 用到了 createElement，那么是否可以重写原生 createElement 呢？但是除了createElement 还有 createElementNS ，还有可能是页面上已经存在 iframe，所以不合适。</p>
<ul>
<li>那就在每当新创建一个新 iframe 时，对 setAttribute 进行保护重写，这里又有用到 MutationObserver ：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用 MutationObserver 对生成的 iframe 页面进行监控，</span><br><span class="line"> * 防止调用内部原生 setAttribute 及 document.write</span><br><span class="line"> * @return &#123;[type]&#125; [description]</span><br><span class="line"> */</span><br><span class="line">function defenseIframe() &#123;</span><br><span class="line">  // 先保护当前页面</span><br><span class="line">  installHook(window);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 实现单个 window 窗口的 setAttribute保护</span><br><span class="line"> * @param  &#123;[BOM]&#125; window [浏览器window对象]</span><br><span class="line"> * @return &#123;[type]&#125;       [description]</span><br><span class="line"> */</span><br><span class="line">function installHook(window) &#123;</span><br><span class="line">  // 重写单个 window 窗口的 setAttribute 属性</span><br><span class="line">  resetSetAttribute(window);</span><br><span class="line"> </span><br><span class="line">  // MutationObserver 的不同兼容性写法</span><br><span class="line">  var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;</span><br><span class="line"> </span><br><span class="line">  // 该构造函数用来实例化一个新的 Mutation 观察者对象</span><br><span class="line">  // Mutation 观察者对象能监听在某个范围内的 DOM 树变化</span><br><span class="line">  var observer = new MutationObserver(function(mutations) &#123;</span><br><span class="line">    mutations.forEach(function(mutation) &#123;</span><br><span class="line">      // 返回被添加的节点,或者为null.</span><br><span class="line">      var nodes = mutation.addedNodes;</span><br><span class="line"> </span><br><span class="line">      // 逐个遍历</span><br><span class="line">      for (var i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        var node = nodes[i];</span><br><span class="line"> </span><br><span class="line">        // 给生成的 iframe 里环境也装上重写的钩子</span><br><span class="line">        if (node.tagName == &apos;IFRAME&apos;) &#123;</span><br><span class="line">          installHook(node.contentWindow);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  observer.observe(document, &#123;</span><br><span class="line">    subtree: true,</span><br><span class="line">    childList: true</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 重写单个 window 窗口的 setAttribute 属性</span><br><span class="line"> * @param  &#123;[BOM]&#125; window [浏览器window对象]</span><br><span class="line"> * @return &#123;[type]&#125; [description]</span><br><span class="line"> */</span><br><span class="line">function resetSetAttribute(window) &#123;</span><br><span class="line">  // 保存原有接口</span><br><span class="line">  var old_setAttribute = window.Element.prototype.setAttribute;</span><br><span class="line"> </span><br><span class="line">  // 重写 setAttribute 接口</span><br><span class="line">  window.Element.prototype.setAttribute = function(name, value) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们定义了一个 installHook 方法，参数是一个 window ，在这个方法里，我们将重写传入的 window 下的 setAttribute ，并且安装一个 MutationObserver ，并对此窗口下未来可能创建的 iframe 进行监听，如果未来在此 window 下创建了一个 iframe ，则对新的 iframe 也装上 installHook 方法，以此进行层层保护。</p>
</blockquote>
<h3 id="重写-document-write"><a href="#重写-document-write" class="headerlink" title="重写 document.write"></a>重写 document.write</h3><p>根据上述的方法，我们可以继续挖掘一下，还有什么方法可以重写，以便对页面进行更好的保护。</p>
<p>document.write 是一个很不错选择，注入攻击者，通常会使用这个方法，往页面上注入一些弹窗广告。</p>
<ul>
<li>我们可以重写 document.write ，使用关键词黑名单对内容进行匹配。</li>
</ul>
<p>什么比较适合当黑名单的关键字呢？我们可以看看一些广告很多的页面：</p>
<p><img src="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816175136203-1054607098.png" alt="image"></p>
<p>这里在页面最底部嵌入了一个 iframe ，里面装了广告代码，这里的最外层的 id 名id=”BAIDU_SSP__wrapper_u2444091_0” 就很适合成为我们判断是否是恶意代码的一个标志，假设我们已经根据拦截上报收集到了一批黑名单列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 建立正则拦截关键词</span><br><span class="line">var keywordBlackList = [</span><br><span class="line">&apos;xss&apos;,</span><br><span class="line">&apos;BAIDU_SSP__wrapper&apos;,</span><br><span class="line">&apos;BAIDU_DSPUI_FLOWBAR&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">接下来我们只需要利用这些关键字，对 document.write 传入的内容进行正则判断，就能确定是否要拦截document.write 这段代码。</span><br><span class="line"></span><br><span class="line">// 建立关键词黑名单</span><br><span class="line">var keywordBlackList = [</span><br><span class="line">  &apos;xss&apos;,</span><br><span class="line">  &apos;BAIDU_SSP__wrapper&apos;,</span><br><span class="line">  &apos;BAIDU_DSPUI_FLOWBAR&apos;</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 重写单个 window 窗口的 document.write 属性</span><br><span class="line"> * @param  &#123;[BOM]&#125; window [浏览器window对象]</span><br><span class="line"> * @return &#123;[type]&#125;       [description]</span><br><span class="line"> */</span><br><span class="line">function resetDocumentWrite(window) &#123;</span><br><span class="line">  var old_write = window.document.write;</span><br><span class="line"> </span><br><span class="line">  window.document.write = function(string) &#123;</span><br><span class="line">    if (blackListMatch(keywordBlackList, string)) &#123;</span><br><span class="line">      console.log(&apos;拦截可疑模块:&apos;, string);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 调用原始接口</span><br><span class="line">    old_write.apply(document, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * [黑名单匹配]</span><br><span class="line"> * @param  &#123;[Array]&#125; blackList [黑名单]</span><br><span class="line"> * @param  &#123;[String]&#125; value    [需要验证的字符串]</span><br><span class="line"> * @return &#123;[Boolean]&#125;         [false -- 验证不通过，true -- 验证通过]</span><br><span class="line"> */</span><br><span class="line">function blackListMatch(blackList, value) &#123;</span><br><span class="line">  var length = blackList.length,</span><br><span class="line">    i = 0;</span><br><span class="line"> </span><br><span class="line">  for (; i &lt; length; i++) &#123;</span><br><span class="line">    // 建立黑名单正则</span><br><span class="line">    var reg = new RegExp(whiteList[i], &apos;i&apos;);</span><br><span class="line"> </span><br><span class="line">    // 存在黑名单中，拦截</span><br><span class="line">    if (reg.test(value)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以把 resetDocumentWrite 放入上文的 installHook 方法中，就能对当前 window 及所有生成的 iframe 环境内的 document.write 进行重写了。</li>
</ul>
<h2 id="锁死-apply-和-call"><a href="#锁死-apply-和-call" class="headerlink" title="锁死 apply 和 call"></a>锁死 apply 和 call</h2><p>接下来要介绍的这个是锁住原生的 Function.prototype.apply 和 Function.prototype.call 方法，锁住的意思就是使之无法被重写。</p>
<p>这里要用到 Object.defineProperty ，用于锁死 apply 和 call。</p>
<blockquote>
<p>Object.defineProperty</p>
<p>Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</p>
<p>Object.defineProperty(obj, prop, descriptor)  </p>
</blockquote>
<ul>
<li>obj – 需要定义属性的对象</li>
<li>prop – 需被定义或修改的属性名</li>
<li>descriptor – 需被定义或修改的属性的描述符</li>
</ul>
<p>我们可以使用如下的代码，让 call 和 apply 无法被重写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 锁住 call</span><br><span class="line">Object.defineProperty(Function.prototype, &apos;call&apos;, &#123;</span><br><span class="line">  value: Function.prototype.call,</span><br><span class="line">  // 当且仅当仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变</span><br><span class="line">  writable: false,</span><br><span class="line">  // 当且仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: true</span><br><span class="line">&#125;);</span><br><span class="line">// 锁住 apply</span><br><span class="line">Object.defineProperty(Function.prototype, &apos;apply&apos;, &#123;</span><br><span class="line">  value: Function.prototype.apply,</span><br><span class="line">  writable: false,</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>为啥要这样写呢？其实还是与上文的 重写 setAttribute 有关。</li>
</ul>
<p>虽然我们将原始 Element.prototype.setAttribute 保存在了一个闭包当中，但是还有奇技淫巧可以把它从闭包中给“偷出来”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;&#125;)(</span><br><span class="line">    // 保存原有接口</span><br><span class="line">    var old_setAttribute = Element.prototype.setAttribute;</span><br><span class="line">    // 重写 setAttribute 接口</span><br><span class="line">    Element.prototype.setAttribute = function(name, value) &#123;</span><br><span class="line">        // 具体细节</span><br><span class="line">        if (this.tagName == &apos;SCRIPT&apos; &amp;&amp; /^src$/i.test(name)) &#123;&#125;</span><br><span class="line">        // 调用原始接口</span><br><span class="line">        old_setAttribute.apply(this, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">)();</span><br><span class="line">// 重写 apply</span><br><span class="line">Function.prototype.apply = function()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">// 调用 setAttribute</span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].setAttribute(&apos;data-test&apos;,&apos;123&apos;);</span><br></pre></td></tr></table></figure>
<p>猜猜上面一段会输出什么？看看：<br><img src="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816175507062-1668275500.png" alt="image"></p>
<p>居然返回了原生 setAttribute 方法！</p>
<blockquote>
<p>这是因为我们在重写 Element.prototype.setAttribute 时最后有 old_setAttribute.apply(this, arguments);这一句，使用到了 apply 方法，所以我们再重写 apply ，输出 this ，当调用被重写后的 setAttribute 就可以从中反向拿到原生的被保存起来的 old_setAttribute 了。</p>
</blockquote>
<p>这样我们上面所做的嵌套 iframe 重写 setAttribute 就毫无意义了。</p>
<p>使用上面的 Object.defineProperty 可以锁死 apply 和 类似用法的 call 。使之无法被重写，那么也就无法从闭包中将我们的原生接口偷出来。这个时候才算真正意义上的成功重写了我们想重写的属性。</p>
<h2 id="建立拦截上报"><a href="#建立拦截上报" class="headerlink" title="建立拦截上报"></a>建立拦截上报</h2><p>防御的手段也有一些了，接下来我们要建立一个上报系统，替换上文中的 console.log() 日志。</p>
<p>上报系统有什么用呢？因为我们用到了白名单，关键字黑名单，这些数据都需要不断的丰富，靠的就是上报系统，将每次拦截的信息传到服务器，不仅可以让我们程序员第一时间得知攻击的发生，更可以让我们不断收集这类相关信息以便更好的应对。</p>
<ul>
<li>这里的示例我用 nodejs 搭一个十分简易的服务器接受 http 上报请求。</li>
</ul>
<p>先定义一个上报函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义上报 -- 替换页面中的 console.log()</span><br><span class="line"> * @param  &#123;[String]&#125; name  [拦截类型]</span><br><span class="line"> * @param  &#123;[String]&#125; value [拦截值]</span><br><span class="line"> */</span><br><span class="line">function hijackReport(name, value) &#123;</span><br><span class="line">  var img = document.createElement(&apos;img&apos;),</span><br><span class="line">    hijackName = name,</span><br><span class="line">    hijackValue = value.toString(),</span><br><span class="line">    curDate = new Date().getTime();</span><br><span class="line"> </span><br><span class="line">  // 上报</span><br><span class="line">  img.src = &apos;http://www.reportServer.com/report/?msg=&apos; + hijackName + &apos;&amp;value=&apos; + hijackValue + &apos;&amp;time=&apos; + curDate;</span><br></pre></td></tr></table></figure>
<p>假定我们的服务器地址是 www.reportServer.com 这里，我们运用 img.src 发送一个 http 请求到服务器<a href="http://www.reportServer.com/report/" target="_blank" rel="external">http://www.reportServer.com/report/</a> ，每次会带上我们自定义的拦截类型，拦截内容以及上报时间。</p>
<p>用 Express 搭 nodejs 服务器并写一个简单的接收路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var app = express();</span><br><span class="line"> </span><br><span class="line">app.get(&apos;/report/&apos;, function(req, res) &#123;</span><br><span class="line">    var queryMsg = req.query.msg,</span><br><span class="line">        queryValue = req.query.value,</span><br><span class="line">        queryTime = new Date(parseInt(req.query.time));</span><br><span class="line"> </span><br><span class="line">    if (queryMsg) &#123;</span><br><span class="line">        console.log(&apos;拦截类型：&apos; + queryMsg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (queryValue) &#123;</span><br><span class="line">        console.log(&apos;拦截值：&apos; + queryValue);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (queryTime) &#123;</span><br><span class="line">        console.log(&apos;拦截时间：&apos; + req.query.time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.listen(3002, function() &#123;</span><br><span class="line">    console.log(&apos;HttpHijack Server listening on port 3002!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行服务器，当有上报发生，我们将会接收到如下数据：</p>
<p><img src="http://images2015.cnblogs.com/blog/608782/201608/608782-20160816175607671-745079353.png" alt="image"></p>
<p>好接下来就是数据入库，分析，添加黑名单，使用 nodejs 当然拦截发生时发送邮件通知程序员等等，这些就不再做展开。</p>
<h2 id="JavaScript-DDoS攻击防御方法"><a href="#JavaScript-DDoS攻击防御方法" class="headerlink" title="JavaScript DDoS攻击防御方法"></a>JavaScript DDoS攻击防御方法</h2><p>为了解决由于引入第三方恶意脚本导致的DDoS攻击的问题，W3C提出了一个叫做“子资源完整性”（ Subresource Integrity）的新特性，简称SRI。这个新特性允许一个网站告诉浏览器只有在引入的脚本满足需求时才会进行解析并运行。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://xxx/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的这个<script>标签引入了最新稳定版的jQuery代码，如果其中被插入了恶意脚本，浏览器也会不加分辨的运行。而使用了SRI新特性之后，浏览器将会根据代码的加密哈希来对引入的代码进行判断。加密哈希就好比一个文件的指纹一般，不同的文件将会产出不同的加密哈希值。如果其中被添加了恶意脚本，则浏览器会因为加密哈希不匹配而拒绝执行引入的代码。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://code.jquery.com/jquery-1.10.2.min.js&quot;  </span><br><span class="line">    integrity=&quot;sha256-C6CB9UYIS9UJeqinPHWTHVqh/E1uhG5Twh+Y5qFQmYg=&quot;</span><br><span class="line">    crossorigin=&quot;anonymous&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的script标签上，多添加了两个属性，其中的integrity是加载的jquery版本的加密哈希值，用于判定判定加载进来的脚本是否符合我们的期望。如果你不了解你需要加载的JS脚本的加密哈希值，可以通过<a href="https://srihash.org/这个网站进行计算。同时，crossorgin属性和http">https://srihash.org/这个网站进行计算。同时，crossorgin属性和http</a> header中的CORS属性能够保证浏览器遵守同源属性并防止XSS攻击。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://web.jobbole.com/87561/">JavaScript 防 http 劫持与 XSS</a><br><a href="https://blog.cloudflare.com/an-introduction-to-javascript-based-ddos/">An introduction to JavaScript-based DDoS</a></p>
</script></p>
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端知识总结/" rel="tag">#前端知识总结</a>
          
            <a href="/tags/网络安全/" rel="tag">#网络安全</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/05/前端路由的简单实现/" rel="next" title="前端路由的简单实现">
                <i class="fa fa-chevron-left"></i> 前端路由的简单实现
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/21/sea-js源码（Module-js核心代码）/" rel="prev" title="sea.js源码（Module.js核心代码）">
                sea.js源码（Module.js核心代码） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/31/JavaScript防http劫持与XSS/"
           data-title="JavaScript防http劫持与XSS" data-url="http://yoursite.com/2016/08/31/JavaScript防http劫持与XSS/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="吴晓鑫" />
          <p class="site-author-name" itemprop="name">吴晓鑫</p>
          <p class="site-description motion-element" itemprop="description">一寸光阴一寸金，三寸光阴一个鑫。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wxx2258" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见网络攻击"><span class="nav-number">1.</span> <span class="nav-text">常见网络攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS跨站脚本"><span class="nav-number">1.1.</span> <span class="nav-text">XSS跨站脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSRF跨站请求伪造"><span class="nav-number">1.2.</span> <span class="nav-text">CSRF跨站请求伪造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP劫持"><span class="nav-number">1.3.</span> <span class="nav-text">HTTP劫持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS劫持"><span class="nav-number">1.4.</span> <span class="nav-text">DNS劫持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面被嵌入iframe-，重定向iframe"><span class="nav-number">2.</span> <span class="nav-text">页面被嵌入iframe ，重定向iframe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用白名单放行正常iframe嵌套"><span class="nav-number">3.</span> <span class="nav-text">使用白名单放行正常iframe嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更改-URL-参数绕过运营商标记"><span class="nav-number">4.</span> <span class="nav-text">更改 URL 参数绕过运营商标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联事件和内联脚本拦截"><span class="nav-number">5.</span> <span class="nav-text">内联事件和内联脚本拦截</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态脚本拦截"><span class="nav-number">6.</span> <span class="nav-text">静态脚本拦截</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用白名单对src进行匹配过滤"><span class="nav-number">6.1.</span> <span class="nav-text">使用白名单对src进行匹配过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态脚本拦截"><span class="nav-number">7.</span> <span class="nav-text">动态脚本拦截</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写setAttribute-与-document-write"><span class="nav-number">8.</span> <span class="nav-text">重写setAttribute 与 document.write</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重写嵌套-iframe-内的-Element-prototype-setAttribute"><span class="nav-number">8.1.</span> <span class="nav-text">重写嵌套 iframe 内的 Element.prototype.setAttribute</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写-document-write"><span class="nav-number">8.2.</span> <span class="nav-text">重写 document.write</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁死-apply-和-call"><span class="nav-number">9.</span> <span class="nav-text">锁死 apply 和 call</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建立拦截上报"><span class="nav-number">10.</span> <span class="nav-text">建立拦截上报</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-DDoS攻击防御方法"><span class="nav-number">11.</span> <span class="nav-text">JavaScript DDoS攻击防御方法</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴晓鑫</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wxx2258"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  


</body>
</html>
